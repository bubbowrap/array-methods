<script src="../simpletest.js"></script>
<!-- <script src="adder.js"></script> -->
<script>

//SUMMARY:

// sorts the elements of an array in place and returns the sorted array. The default sort order is built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.

// PROTOTYPE IMPLEMENTATION:

function sort(array, compareFunction) {


  return newArray;
}

//FUNCTION SIGNATURE (the way we want it to be called):

// sort(array, target, start[optional], end[optional]);


//RETURN VALUE:

// The sorted array. Note that the array is sorted in place, and no copy is made.


//REQUIREMENTS:

// should return an array
// sequence should be copied to the target.
// If negative, target will be counted from the end.
// If target is at or greater than arr.length, nothing will be copied
// If target is positioned after start, the copied sequence will be trimmed to fit arr.length.
// if no target, just return the array
// element should start copying from index passed into start
// if negative, start should be counted from the end
// if start is omitted, it should copy from index 0
// element should stop copying up to but not including the end
// if negative, end will be counted from the end
// if end is omitted, it should count until the last index (arr.length)
// if empty, just return the empty array

// pasted sequence will have the copied values even when the copy and paste region overlap.
// It should be mutable 
// It does not alter the length of this, but it will change its content and create new properties, if necessary.

//ALSO/EDGE CASES

//COME BACK TO:

// see what it does for NaN and holes
// write throw error



//tests methods
tests ({
  'should pass in an array as the first argument, else return error': function() {
    fail();
    eq(Array.isArray(thisArr), true);
  },
  'sequence should be copied to the target': function(){
    var thisArr = [1,2,3,4];
    var cwArray = copyWithin(thisArr, 1);
    eq(thisArr[1] === 1, true);
  },
  'If negative, target will be counted from the end.': function(){
    var cwArray = copyWithin([1, 2, 3, 4, 5], -2, -3, -1);
    eq(cwArray[3] === 3, true);
    eq(cwArray[4] === 4, true);
  },
  'If target is at or greater than arr.length, nothing will be copied': function() {
    var cwArray = copyWithin([1, 2, 3, 4, 5], 5, -3, -1);
    eq(cwArray[3] === 4, true);
    eq(cwArray[4] === 5, true);  
  },
  'If target is positioned after start, the copied sequence will be trimmed to fit arr.length': function() {
    var orgArray = [1, 2, 3, 4, 5];
    var cwArray = copyWithin(orgArray, 5, -3, -1);
    eq(orgArray.length === cwArray.length, true);
  },
  'if no target, just return the array': function() {
    var orgArray = [1, 2, 3, 4, 5];
    var cwArray = copyWithin(orgArray);
    console.log(cwArray);
    eq(orgArray == cwArray, true);  
  },
  'element should start copying from index passed into start': function() {
    fail();
  },
  'if start is omitted, it should copy from index 0': function() {
    fail();
  },
  'if negative, start should be counted from the end': function() {
    fail();
  },
  'element should stop copying up to but not including the end': function() {
    fail();
  },
  'if end is omitted, it should count until the last index (arr.length)': function() {
    var orgArray = [1, 2, 3, 4, 5];
    var cwArray = copyWithin(orgArray, 3, 4);
    console.log(cwArray);
    eq(cwArray[4] == 5, true);
  },
  'if negative, end will be counted from the end': function() {
    var orgArray = [1, 2, 3, 4, 5];
    var cwArray = copyWithin(orgArray, 3, 0, -3);
    console.log(cwArray);
    eq(cwArray[3] == 1, true);
    eq(cwArray[4] == 2, true);
  },
  'if array is empty, just return the empty array': function() {
    var orgArray = [];
    var cwArray = copyWithin(orgArray, 1, 2, 3);
    console.log(cwArray);
    eq(orgArray == cwArray, true);    
  },
  'pasted sequence will have the copied values even when the copy and paste region overlap': function() {
    fail();
  },
  'It should be mutable': function() {
    fail();
  },
  'It does not alter the length of this, but it will change its content and create new properties, if necessary.': function() {
    fail();
  }
});
</script>
<script src="../simpletest.js"></script>
<!-- <script src="adder.js"></script> -->
<script>

//SUMMARY:

// Determines whether an array includes a certain value among its entries, returning true or false as appropriate.

//PROTOTYPE IMPLEMENTATION:

// function includes(array, elementToLocate, whereToStart) {
//  var length = array.length;

//  should loop through items and return true if so; otherwise return false;
//  if (whereToStart) {
//    for (var i = whereToStart; i < length; i++) {
//      if (array[i] === elementToLocate) {
//        return true;
//      }
//    }
//  } else {
//    for (var i = 0; i < length; i++) {
//      if (array[i] === elementToLocate) {
//        return true;
//      }
//    }
//  }
//  return false;
// }


//FUNCTION SIGNATURE (the way we want it to be called):

// includes(array, valueToFind[, fromIndex])


//RETURN VALUE:

// A Boolean which is true if the value valueToFind is found within the array (or the part of the array indicated by the index fromIndex, if specified).

//REQUIREMENTS:

// It should return a boolean
// should loop through all arguments
// if element located, exit loop and return true immediately
// if element not located, return false
// should pass in an array as the first argument
// if first arg is not an array, return type error: TypeError: element.concat is not a function

// the first character to be searched is found at fromIndex for positive values of fromIndex
//If fromIndex is greater than or equal to the length of the array, false is returned. The array will not be searched.
//  or at array.length + fromIndex for negative values of fromIndex (offset from end of array)
// If the computed index is less or equal than -1 * array.length, the entire array will be searched.
// Values of zero are all considered to be equal regardless of sign (that is, -0 is considered to be equal to both 0 and +0)
// false is not considered to be the same as 0

// When comparing strings and characters, includes() is case-sensitive

//COME BACK TO:

// see what it does for NaN/undefined/null/holes
// write throw error

function includes(array, elementToLocate, whereToStart) {
 var length = array.length;

 //should loop through items and return true if so; otherwise return false;
 if (whereToStart) {
   for (var i = whereToStart; i < length; i++) {
     if (array[i] === elementToLocate) {
       return true;
     }
   }
 } else {
   for (var i = 0; i < length; i++) {
     if (array[i] === elementToLocate) {
       return true;
     }
   }
 }
 return false;
}

//tests methods
tests ({
  'It should return last index of array': function() {
    var returnedIndex = lastIndexOf([1,'cat',3,2], 'cat');
      eq(returnedIndex, 1);
      eq(isNaN(returnedIndex), false);
  },
  'Should pass in an array as the first argument': function(){
    var orgArray = [1,2,3];
    var returnedIndex = lastIndexOf(orgArray, 2);
    eq(Array.isArray(orgArray), true);
  },
  'Should throw error if not an Array': function() {
    fail();
  },
  'if item not found, return -1': function() {
    var returnedIndex = lastIndexOf([1,2,3], 4);
    eq(returnedIndex, -1);
  },
  'Should start searching from specified index': function() {
    var returnedIndex = lastIndexOf([2,3,2,2], 2, 1);
    eq(returnedIndex, 0);
  },
  'If the index is greater than or equal to the length of the array, the whole array will be searched.': function() {
    var returnedIndex = lastIndexOf([2,3,2], 2, 8);
    eq(returnedIndex, 2);
  },
  'If negative, it is taken as the offset from the end of the array' : function() {
    var returnedIndex = lastIndexOf([2,3,3,4,2], 2, -2);
    eq(returnedIndex, 0);
  },
  'even when the index is negative, the array is still searched from back to front. ': function() {
    var returnedIndex = lastIndexOf([1,2,3,2], 2, -1);
    eq(returnedIndex, 1);
  },

  'If the calculated index is less than 0, -1 is returned, i.e. the array will not be searched': function() {
    var returnedIndex = lastIndexOf([1,2,3,2], 2, -9);
    eq(returnedIndex, -1);
  }
});

</script>
